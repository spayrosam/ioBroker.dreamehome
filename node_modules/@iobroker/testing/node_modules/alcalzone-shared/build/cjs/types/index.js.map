{
  "version": 3,
  "sources": ["../../../src/types/index.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/**\n * Negates a boolean\n */\nexport type Not<T extends boolean> = T extends true ? false : true;\n\n/**\n * Combines two booleans using logical AND\n */\nexport type And<T1 extends boolean, T2 extends boolean> =\n\t// if one of the arguments is exactly false, return false\n\tT1 extends false ? false : T2 extends false ? false : true;\n\n/**\n * Combines two booleans using logical AND\n */\nexport type Or<T1 extends boolean, T2 extends boolean> =\n\t// if one of the arguments is exactly true, return true\n\tT1 extends true ? true : T2 extends true ? true : false;\n\n/**\n * Tests if the type TSource is assignable to TTarget\n */\nexport type AssignableTo<TSource, TTarget> = [TSource] extends [TTarget]\n\t? true\n\t: false;\n\n/**\n * Tests if two types are equal\n */\nexport type Equals<T, S> = [T] extends [S]\n\t? [S] extends [T]\n\t\t? true\n\t\t: false\n\t: false;\n\n/**\n * Creates a union from the numeric keys of an Array or tuple.\n * The result is the union of all fixed entries and (if open-ended or an array) the type `number`\n */\nexport type IndizesOf<\n\tT extends any[],\n\tU = Omit<T, keyof []>,\n\tNumericKeysOfT = keyof U,\n> =\n\t| NumericKeysOfT\n\t// take the numeric keys of T\n\t// and add number if this is an array or open-ended tuple\n\t| (number extends LengthOf<T> ? number : never);\n\n/**\n * Creates a union from the numeric keys of an Array or tuple.\n * The result is the union of all fixed entries, but unlike `IndizesOf` does not include the type `number`\n */\nexport type FixedIndizesOf<T extends any[]> = keyof Omit<T, keyof []>;\n\n/**\n * Creates a union from the types of an Array or tuple\n */\nexport type UnionOf<T extends any[]> = T[number];\n\n/**\n * Returns the length of an array or tuple\n */\nexport type LengthOf<T extends any[]> = T extends { length: infer R }\n\t? R\n\t: never;\n\nexport type IsFixedLength<T extends any[]> =\n\t// if the length property is `number`, this is not fixed length\n\tnumber extends LengthOf<T> ? false : true;\n\nexport type IsVariableLength<T extends any[]> = Not<IsFixedLength<T>>;\n\n/**\n * Tests if a type is a fixed-length tuple (true) or an Array/open-ended tuple (false)\n */\nexport type IsTuple<T extends any[]> =\n\tIsFixedLength<T> extends true\n\t\t? true // This is a fixed-length tuple\n\t\t: IndizesOf<T> extends number\n\t\t\t? false // this is an array or an open-ended tuple of the form [...type[]]\n\t\t\t: true; // This is an open-ended tuple with at least 1 item\n\n/** Converts a number between 0 and 99 to its corresponding string representation */\n// prettier-ignore\nexport type ToString<N extends number> = [\n\t\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n\t\"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n\t\"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n\t\"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n\t\"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n\t\"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n\t\"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n\t\"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n\t\"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n\t\"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n][N];\n\n/**\n * Tests if all types in an array or tuple are assignable to T\n */\nexport type Every<TArr extends any[], T> = Equals<UnionOf<TArr>, T>;\n\n/**\n * Tests if all types in an array or tuple are strictly equal to T\n */\nexport type EveryStrict<\n\tTArr extends T[],\n\tT,\n\t// Only keep the type information for numeric indizes of TArr\n\tOnlyTupleKeys = Omit<TArr, keyof []>,\n\t// Test if those are equal to T\n\tTupleKeysEqualT = {\n\t\t[P in keyof OnlyTupleKeys]: Equals<OnlyTupleKeys[P], T>;\n\t},\n\t// Build a union of the results\n\tAllTupleKeysTrue = TupleKeysEqualT[keyof TupleKeysEqualT],\n> = {\n\t// empty tuples: T must be never\n\tempty: Equals<T, never>;\n\t// for tuples: return true if the union equals true\n\ttuple: Equals<AllTupleKeysTrue, true>;\n\t// for array: test the array type for strict equality\n\tarray: T[] extends TArr ? true : false;\n}[TArr extends [] ? \"empty\" : IsTuple<TArr> extends true ? \"tuple\" : \"array\"];\n\n/**\n * Excludes the properties K from type T\n */\nexport type Omit<T, K> = { [P in Exclude<keyof T, K>]: T[P] };\n\n/**\n * Builds a subset of type T with the properties K that are all optional\n */\nexport type Optional<T, K> = { [P in Extract<keyof T, K>]+?: T[P] };\n\n/**\n * Makes the properties K in type T optional\n */\nexport type SemiPartial<T, K extends keyof T> = T extends never\n\t? never\n\t: Omit<T, K> & Optional<T, K>;\n\n/**\n * Extracts a union of possible key-value pairs from type T\n * @returns A union of `{key, value}` objects where `key` can take the values of `keyof T` and `value` the corresponding property types.\n */\nexport type KeyValuePairsOf<\n\tT extends Record<string, any>,\n\tU = { [K in keyof T]: { key: K; value: T[K] } },\n> = U[keyof U];\n\n/**\n * Returns a simplified representation of the type T. For example:\n * Pick<{a: number, b: string }, \"b\"> & { a?: boolean } => { b: string, a?: boolean }\n */\nexport type Simplify<T extends object> = { [K in keyof T]: T[K] };\n\n/**\n * Returns a composite type with the properties of T that are not in U plus all properties from U\n */\nexport type Overwrite<T extends object, U extends object> = Simplify<\n\tOmit<T, keyof T & keyof U> & U\n>;\n\n/**\n * Returns the first item's type in a tuple\n */\nexport type Head<T extends any[]> = T extends [infer R, ...any[]] ? R : never;\n/**\n * Returns all but the first item's type in a tuple/array\n */\nexport type Tail<T extends any[]> =\n\t// Tail is an identity operation for array types (without fixed indizes)\n\t[FixedIndizesOf<T>] extends [never]\n\t\t? T\n\t\t: // For tuples, just omit the first item\n\t\t\tT extends [any, ...infer R]\n\t\t\t? R\n\t\t\t: [];\n/**\n * Returns all but the last item's type in a tuple/array\n */\nexport type Lead<T extends unknown[]> = T extends []\n\t? []\n\t: // tuple with at least one trailing item\n\t\tT extends [...infer L1, infer _]\n\t\t? L1\n\t\t: // tuple with trailing rest element / array\n\t\t\tT extends [...infer L2]\n\t\t\t? L2\n\t\t\t: [];\n\n/**\n * Returns the last item's type in a tuple\n */\nexport type Last<T extends unknown[]> = T extends []\n\t? never\n\t: T extends [...infer _, infer R]\n\t\t? R\n\t\t: T extends [...infer _, (infer R)?]\n\t\t\t? R | undefined\n\t\t\t: never;\n\n/**\n * Returns the given tuple/array with the item type prepended to it\n */\nexport type Unshift<List extends any[], Item> = [Item, ...List];\n\n/**\n * Returns the given tuple/array with the item type appended to it\n */\nexport type Push<List extends any[], Item> = [...List, Item];\n\n/**\n * Concatenates the given tuples\n */\nexport type Concat<T1 extends any[], T2 extends any[]> = [...T1, ...T2];\n\n/**\n * Forces T to be of type Type - This can discard type information\n */\ntype ForceType<T, Type> = T extends Type ? T : Type;\n\n/**\n * Returns the Nth argument of F (0-based)\n */\nexport type ArgumentAt<\n\tF extends (...args: any[]) => any,\n\tN extends number,\n\tNStr extends string = ToString<N>,\n\tArgsTuple extends any[] = Parameters<F>,\n\tRet = IsVariableLength<ArgsTuple> extends true\n\t\t? // keep variable length-tuples as-is\n\t\t\tArgsTuple[N]\n\t\t: // fixed length tuples need their non-existent indizes to be filled with never\n\t\t\tNStr extends IndizesOf<ArgsTuple>\n\t\t\t? ArgsTuple[NStr]\n\t\t\t: never,\n> = Ret;\n\n/** Takes the elements from T2 that have a corresponding index in T1 */\ntype MapTuples<T1 extends any[], T2 extends any[]> = {\n\t[K in keyof T1]: K extends keyof T2 ? T2[K] : never;\n};\n\n/**\n * Marking a parameter of a generic function with `NoInfer` causes its type\n * to be inferred from other arguments with the same type instead of creating a union.\n * Example:\n * ```ts\n const foo = <T>(arg1: T, arg2: T) => arg2;\n foo({a: 1}, {b: 2})\n // gets inferred as {a: number, b?: undefined} | {a?: undefined, b: number}\n const bar = <T>(arg1: T, arg2: NoInfer<T>) => arg2;\n bar({a: 1}, {b: 2})\n // is an error: \"a\" is missing in type {b: 2}\n ```\n */\nexport type NoInfer<T> = T & { [K in keyof T]: T[K] };\n\n/** Returns the type of the last argument of a function */\nexport type LastArgument<T extends (...args: any[]) => any> = Last<\n\tParameters<T>\n>;\n\n/** Returns the \"return\" type of a callback-style API */\nexport type CallbackAPIReturnType<\n\tT extends (...args: any[]) => any,\n\tTCb extends (...args: any[]) => any = LastArgument<T>,\n\tTCbArgs = Parameters<Exclude<TCb, undefined>>,\n> = TCbArgs extends [(Error | null | undefined)?]\n\t? void\n\t: TCbArgs extends [Error | null | undefined, infer U]\n\t\t? U\n\t\t: TCbArgs extends any[]\n\t\t\t? TCbArgs[1]\n\t\t\t: never;\n\n/**\n * Returns a promisified function signature for the given callback-style function.\n */\nexport type Promisify<\n\tT extends (...args: any[]) => any,\n\tTReturn = CallbackAPIReturnType<T>,\n\tTArgs extends any[] = Lead<Parameters<T>>,\n> = (...args: TArgs) => Promise<TReturn>;\n\n// TupleOf type taken from https://github.com/microsoft/TypeScript/issues/26223#issuecomment-674514787\ntype BuildPowersOf2LengthArrays<\n\tN extends number,\n\tR extends never[][],\n> = R[0][N] extends never\n\t? R\n\t: BuildPowersOf2LengthArrays<N, [[...R[0], ...R[0]], ...R]>;\n\ntype ConcatLargestUntilDone<\n\tN extends number,\n\tR extends never[][],\n\tB extends never[],\n> = B[\"length\"] extends N\n\t? B\n\t: [...R[0], ...B][N] extends never\n\t\t? ConcatLargestUntilDone<\n\t\t\t\tN,\n\t\t\t\tR extends [R[0], ...infer U]\n\t\t\t\t\t? U extends never[][]\n\t\t\t\t\t\t? U\n\t\t\t\t\t\t: never\n\t\t\t\t\t: never,\n\t\t\t\tB\n\t\t\t>\n\t\t: ConcatLargestUntilDone<\n\t\t\t\tN,\n\t\t\t\tR extends [R[0], ...infer U]\n\t\t\t\t\t? U extends never[][]\n\t\t\t\t\t\t? U\n\t\t\t\t\t\t: never\n\t\t\t\t\t: never,\n\t\t\t\t[...R[0], ...B]\n\t\t\t>;\n\ntype Replace<R extends any[], T> = { [K in keyof R]: T };\n\n/** Creates a tuple of the given type with the given length */\nexport type TupleOf<T, N extends number> = number extends N\n\t? T[]\n\t: {\n\t\t\t[K in N]: BuildPowersOf2LengthArrays<K, [[never]]> extends infer U\n\t\t\t\t? U extends never[][]\n\t\t\t\t\t? Replace<ConcatLargestUntilDone<K, U, []>, T>\n\t\t\t\t\t: never\n\t\t\t\t: never;\n\t\t}[N];\n\n/**\n * Creates a Union of all numbers (converted to string) from 0 to N (exclusive)\n * WARNING: This uses a recursive type definition which might stop working at any point\n * N = 100000 seems to work currently.\n */\nexport type Range<N extends number> = IndizesOf<TupleOf<never, N>>;\n\n/**\n * Creates a Union of all numbers from N (inclusive) to M (exclusive)\n * WARNING: This uses a recursive type definition which might stop working at any point\n * N = 100000 seems to work currently.\n */\nexport type RangeFrom<N extends number, M extends number> = Exclude<\n\tRange<M>,\n\tRange<N>\n>;\n\n/** Tests if N > M */\nexport type IsGreaterThan<\n\tN extends number,\n\tM extends number,\n\tRangeN = Range<N>,\n\tRangeM = Range<M>,\n\tRangeDiff = Exclude<RangeN, RangeM>,\n> = [RangeDiff] extends [never] ? false : true;\n\n/** Tests if N <= M */\nexport type IsLessThanOrEqual<\n\tN extends number,\n\tM extends number,\n\tRangeN = Range<N>,\n\tRangeM = Range<M>,\n\tRangeDiff = Exclude<RangeN, RangeM>,\n> = [RangeDiff] extends [never] ? true : false;\n\n/** Tests if N < M */\nexport type IsLessThan<\n\tN extends number,\n\tM extends number,\n\tRangeN = Range<N>,\n\tRangeM = Range<M>,\n\tRangeDiff = Exclude<RangeM, RangeN>,\n> = [RangeDiff] extends [never] ? false : true;\n\n/** Tests if N >= M */\nexport type IsGreaterThanOrEqual<\n\tN extends number,\n\tM extends number,\n\tRangeN = Range<N>,\n\tRangeM = Range<M>,\n\tRangeDiff = Exclude<RangeM, RangeN>,\n> = [RangeDiff] extends [never] ? true : false;\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;;",
  "names": []
}
