{
  "version": 3,
  "sources": ["../../../src/async/index.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unsafe-function-type */\nexport function promisify<T>(\n\tfn: Function,\n\tcontext?: any,\n): (...args: any[]) => Promise<T>;\nexport function promisify(fn: Function, context?: any) {\n\treturn function (this: any, ...args: any[]): Promise<any> {\n\t\tcontext = context || this;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfn.apply(context, [\n\t\t\t\t...args,\n\t\t\t\t(error: Error, result: any) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn reject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn resolve(result);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t]);\n\t\t});\n\t};\n}\n\nexport function promisifyNoError<T>(\n\tfn: Function,\n\tcontext?: any,\n): (...args: any[]) => Promise<T>;\nexport function promisifyNoError(fn: Function, context?: any) {\n\treturn function (this: any, ...args: any[]): Promise<any> {\n\t\tcontext = context || this;\n\t\treturn new Promise((resolve) => {\n\t\t\tfn.apply(context, [\n\t\t\t\t...args,\n\t\t\t\t(result: any) => {\n\t\t\t\t\treturn resolve(result);\n\t\t\t\t},\n\t\t\t]);\n\t\t});\n\t};\n}\n/* eslint-enable @typescript-eslint/no-unsafe-function-type */\n\n/**\n * Creates a promise that waits for the specified time and then resolves\n * @param unref Whether `unref()` should be called on the timeout\n */\nexport function wait(ms: number, unref: boolean = false): Promise<void> {\n\treturn new Promise<void>((resolve) => {\n\t\tconst timeout = setTimeout(resolve, ms);\n\t\t// In a browser context (Electron), unref is not necessary or possible\n\t\tif (unref && typeof timeout !== \"number\") timeout.unref();\n\t});\n}\n\nexport type PromiseFactory<T> = () => Promise<T>;\n\n/**\n * Executes the given promise-returning functions in sequence\n * @param promiseFactories An array of promise-returning functions\n * @returns An array containing all return values of the executed promises\n */\nexport async function promiseSequence<T>(\n\tpromiseFactories: Iterable<PromiseFactory<T>>,\n): Promise<T[]> {\n\tconst ret: T[] = [];\n\tfor (const f of promiseFactories) {\n\t\tret.push(await f());\n\t}\n\treturn ret;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAKA;;;;;;;;AAAM,SAAU,UAAU,IAAc,SAAa;AACpD,SAAO,YAAwB,MAAW;AACzC,cAAU,WAAW;AACrB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACtC,SAAG,MAAM,SAAS;QACjB,GAAG;QACH,CAAC,OAAc,WAAe;AAC7B,cAAI,OAAO;AACV,mBAAO,OAAO,KAAK;UACpB,OAAO;AACN,mBAAO,QAAQ,MAAM;UACtB;QACD;OACA;IACF,CAAC;EACF;AACD;AAMM,SAAU,iBAAiB,IAAc,SAAa;AAC3D,SAAO,YAAwB,MAAW;AACzC,cAAU,WAAW;AACrB,WAAO,IAAI,QAAQ,CAAC,YAAW;AAC9B,SAAG,MAAM,SAAS;QACjB,GAAG;QACH,CAAC,WAAe;AACf,iBAAO,QAAQ,MAAM;QACtB;OACA;IACF,CAAC;EACF;AACD;AAOM,SAAU,KAAK,IAAY,QAAiB,OAAK;AACtD,SAAO,IAAI,QAAc,CAAC,YAAW;AACpC,UAAM,UAAU,WAAW,SAAS,EAAE;AAEtC,QAAI,SAAS,OAAO,YAAY;AAAU,cAAQ,MAAK;EACxD,CAAC;AACF;AASA,eAAsB,gBACrB,kBAA6C;AAE7C,QAAM,MAAW,CAAA;AACjB,aAAW,KAAK,kBAAkB;AACjC,QAAI,KAAK,MAAM,EAAC,CAAE;EACnB;AACA,SAAO;AACR;",
  "names": []
}
